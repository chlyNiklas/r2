import cv2
from cv2.typing import MatLike
import numpy as np
import processor.cvlib as cv
from kivy.graphics.texture import Texture


class Cordinator:
    x: float = 0
    y: float = 0

    def offset(self, x: float, y: float) -> None:
        self.x += x
        self.y += y


class Detector:
    last_frame: MatLike | None = None
    proc_frame: MatLike | None = None
    cap: cv2.VideoCapture
    cord: Cordinator

    def __init__(self, cap: cv2.VideoCapture):
        self.cap = cap

    def getFrame(self) -> Texture:
        if self.proc_frame is None:
            return Texture.create()
        buf = self.proc_frame.tobytes()
        image_texture = Texture.create(
            size=(self.proc_frame.shape[1], self.proc_frame.shape[0]), colorfmt="bgr"
        )
        image_texture.blit_buffer(buf, colorfmt="bgr", bufferfmt="ubyte")
        return image_texture

    def imgShow(self):
        if self.proc_frame is None:
            return
        cv2.imshow("Frame", self.proc_frame)

    def calcMovement(self, frame: MatLike) -> None:
        frame = cv2.resize(frame, None, None, 0.5, 0.5, cv2.INTER_CUBIC)
        if self.last_frame is None:
            self.last_frame = frame
            return

        try:
            flow = cv2.calcOpticalFlowFarneback(
                self.last_frame, frame, None, 0.5, 3, 15, 3, 5, 1.2, 0
            )
            x = np.median(flow[..., 0]) * 2
            y = np.median(flow[..., 1]) * 2
            print(x, y)
        except cv2.error as e:
            print(e)
        except IndexError:
            pass

        self.last_frame = frame

    def process(self):
        if not self.cap.isOpened():
            return

        ret, frame = self.cap.read()

        if not ret:
            return

        img = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)  # convert to Grayscale

        self.proc_frame = frame

        self.calcMovement(img)

        ## remove large patches
        patches = cv.detect_patches(img, 40)
        img = cv2.subtract(img, patches)

        _, img = cv2.threshold(img, 200, 255, cv2.THRESH_BINARY_INV)  # apply threshold

        blobs = cv.detect_blobs(img)
        self.proc_frame = cv.drawKeyPts(frame, blobs, (0, 0, 225))
